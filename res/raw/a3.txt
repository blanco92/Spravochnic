<h3>ListView в Android</h3>

Как правильно работать с ListView в Android. Начать стоит со скачивания эклипса, установки SDK, плагина, в Интернете об этом много чего. Итак, после создания проекта имеем сгенеренную Activity с вот таким незамысловатым кодом: 
<p>public class Main extends Activity { /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } }
 Переходим в res/layout/main.xml . Кстати, вы в курсе, что elcipse умеет искать классы по ctrl+shift+T и файлы по ctrl+shift+R. Оч. удобно, одним словом. main.xml: Хеловорлд нам больше ни к чему, уберем его отсюда, а на его место поставим ListView Теперь немного отвлечемся от кода и поговорим ListView в Android работает не сам по себе. Он работает через адаптер, т. е. нельзя просто так сказать: "Глубокоуважаемый listView, добавьте в себя, пожалуйста вот этот элемент, вот этот и еще этот.". Вместо этого стоит говорить: "listView, вот тебе адаптер, он знает что и как делать, вы сработаетесь". А всё это сделано для того, чтобы листы не собо томозили: в каждый момент времени лист отражает несколько элементов (те, которые "влезают" в экран), а при пролистывании вместо того, чтобы создавать новые и новые, новые элементы списка становятся на место старых. В предыдущий абзац вникать не надо. Вроде ничего не понятно, как и планировалось. Итак (указываем listView, с каким ему работать адаптером): @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); listView = (ListView) findViewById(R.id.listView); listView.setAdapter(null); } Ага! Попались! У нас же нет адаптера, который сам всё знает! Не проблема. Для описания адаптера воспользуемся альма-матер всех адаптеров - BaseAdapter. Когда мы создадим потомка от BaseAdapter, увидим, что необходимо определить некоторые абстрактные методы. Конкретно: public class MyAdapter extends BaseAdapter { @Override public int getCount() { // TODO Auto-generated method stub return 0; } @Override public Object getItem(int arg0) { // TODO Auto-generated method stub return null; } @Override public long getItemId(int position) { // TODO Auto-generated method stub return 0; } @Override public View getView(int position, View convertView, ViewGroup parent) { // TODO Auto-generated method stub return null; } } Обратимся к документации getCount : How many items are in the data set represented by this Adapter. Сколько элементов в наборе данных (массиве, таблице и т.д., данные можно хоть сосать онлайн (ну, наверное)) getItem : Get the data item associated with the specified position in the data set. Получить из набора элемент данных, связанный с определенной позицией getItemId : Get the row id associated with the specified position in the list. Получить id строки, которой принадлежит элемент данных (в таблице, массиве, чем угодно), связанный с определенной позицией в ListView (Самое интересное) getView Get a View that displays the data at the specified position in the data set. You can either create a View manually or inflate it from an XML layout file. When the View is inflated, the parent View (GridView, ListView...) will apply default layout parameters unless you use inflate(int, android.view.ViewGroup, boolean) to specify a root view and to prevent attachment to the root. Получить View (это может быть любая View - TextView, Button, ImageView), которая отражает данные, связанные с определенной позицией в наборе. Её можно создать из java-кода, можно "состряпать из xml", это не так важно. После её "накачки" (ну, всмысле, создания) родитель (в данном случае наш ListView, а этом может быть не только ListView, а, например, GridView, Gallery, и т. д.) применит к ней стандартные настройки отображения, кроме тех случаев, когда вы ухитритесь обойти это дело=) Параметры position Позиция элемента данных в наборе, для которого ListView хочет получить View convertView The old view to reuse, if possible. Note: You should check that this view is non-null and of an appropriate type before using. If it is not possible to convert this view to display the correct data, this method can create a new view. Heterogeneous lists can specify their number of view types, so that this View is always of the right type (see getViewTypeCount() and getItemViewType(int)). "Старая" View для её повторного использования, если это возможно (в наше время ни в чем нельзя быть уверенным на 100%). Именно за счет этого повторного использования система избегает создания новых и новых визуальных элементов (а это - довольно затратная по ресурсам операция). То есть, например, при пролистывании списка на место элемента с номером 10 встанет элемент с номером 11. Для этого не нужно создавать новый визуальный элемент, а достаточно просто отобразить данные из ячейки номер 11 на элемент номер 10 в списке (элемент №10 в списке мы получаем в качестве параметра convertView, позицию нового элемента данных для отображения в "бывшей в употреблении" view - в параметре position). Дальше в документации идет про то, что convertView нужно проверить на null (тогда действительно нужно создать новый визуальный элемент), убедится, что она того типа, который нам нужен (это для гетерогенных листов - сейчас мы их не рассматриваем). parent Родитель (наш ListView), к которому будет прицеплена создаваемая (или совсем даже не создаваемая) нами View для конкретного элемента данных Итак. Пишем. Для начала опишем и забудем визуальный элемент списка (я назвал его string_view.xml): И дописываем MyAdapter до потребного состояния: package ru.pomeshikov; import java.util.List; import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.TextView; public class MyAdapter extends BaseAdapter { private List dataSet; private Context context; public MyAdapter(List dataSet, Context context){ this.dataSet = dataSet; this.context = context; } @Override public int getCount() { return dataSet.size(); } @Override public Object getItem(int arg0) { return dataSet.get(arg0); } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { View result = null; if(convertView != null){ result = convertView; } else { LayoutInflater inflater = LayoutInflater.from(context); View newStringView = inflater.inflate(R.layout.string_view, parent, false); // Мы вынуждены устанавливать layoutParams нашему новому элементу списка такими, чтобы ListView их "понял", иначе упадет ClassCastException newStringView.setLayoutParams(new AbsListView.LayoutParams(AbsListView.LayoutParams.FILL_PARENT, AbsListView.LayoutParams.WRAP_CONTENT)); result = newStringView; } // Нам в любом случае нужно обновить содержимое элемента, ведь мы освобождаемся лишь от создания нового элемента // За нас обновлять содержимое никто не будет TextView textView = (TextView) result.findViewById(R.id.textView); textView.setText(dataSet.get(position)); return result; }